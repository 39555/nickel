%use "ast".
%use "utils".

typecheck : expr -> typ -> prop.
typecheckTypes : typ -> prop.

typecheck (let (bind Name E) (bind Name B)) T :-
    (typecheck (named Name) T' ->
        (typecheck (E (named Name)) T',
        typecheck (B (named Name)) T)).

typecheck (lam (bind Name B)) (tarrow S T) :-
    (typecheck (named Name) S ->
    typecheck (B (named Name)) T).

typecheck (app A B) T :-
    typecheck A (tarrow S T),
    typecheck B S.

typecheck (eint _) tnum.
typecheck (ebool _) tbool.
typecheck (estr _) tstr.

typecheck (ite C T E) Ty :-
    typecheck C tbool,
    typecheck T Ty,
    typecheck E Ty.

typecheck (eunop blame L) _ :-
    typecheck L tlbl.
    
typecheck (eunop isNum _) tbool.
typecheck (eunop isBool _) tbool.
typecheck (eunop isFun _) tbool.

typecheck (ebinop A _ B) tnum :-
    typecheck A tnum,
    typecheck B tnum.

typecheck E Ty :-
    not (refl.isunif Ty),
    eq Ty (forall (bind _ F)),
    (x: typ ->
        typecheck E (F x)).

typecheck (promise Ty E) Ty :-
    typecheckTypes Ty,
    typecheck E Ty.
typecheck (promise Ty E) _ :-
    typecheckTypes Ty,
    not (typecheck E Ty),
    log_error Ty `Couldnt check Promise(...)`,
    failure.

(* The type of an Assume construct doesn't depend on the term *)
typecheck (assume Ty L E) Ty :- 
    typecheckTypes Ty,
    typecheck L tlbl,
    typecheck E _.

typecheck (label _ _) tlbl.

typecheck_dyn : dyn -> prop.
typecheck_dyn (dyn A) :-
    typecheck A _.
typecheck_dyn (dyn A) :-
    not (typeq A (X: typ)),
    structural_map0 typecheck_dyn (dyn A).

typecheck A tdyn :-
    not (eq A (promise _ _)),
    (* Still traverse *)
    structural_map0 typecheck_dyn (dyn A).

typecheckTypes_ : dyn -> prop.

typecheckTypes A :- typecheckTypes_ (dyn A).

typecheckTypes_ (dyn A) :-
    case A [
        (fromExpr E, typecheck E (tarrow tlbl (tarrow S S))),
        (Other, structural_map0 typecheckTypes_ (dyn Other))
    ].
typecheckTypes_ (dyn B) :-
    not (typeq B (X: typ)),
    structural_map0 typecheckTypes_ (dyn B).
