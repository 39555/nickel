%use "ast".

(* We extend the AST to terms related to the execution,
 * and add some operations on them
 *)

(* Negation of the label *)
neg : expr -> expr.
pos : expr -> expr.

(* Used for lazy evaluation *)
thunk : string -> expr -> expr -> expr.
recThunk : string -> (expr -> expr) -> expr -> expr.

(* wrapping of values *)
wrapper : expr -> A -> expr.
unwrap : expr -> A -> expr -> expr.

(* Get the expression contract of a given type *)
typToExpr : typ -> expr -> prop.
typToExpr tdyn (lam (bind _ (fun l => lam (bind _ 
  (fun t => t))))).
typToExpr tnum (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isNum t) t (eunop blame l)))))).
typToExpr tbool (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isBool t) t (eunop blame l)))))).
typToExpr tstr (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isStr t) t (eunop blame l)))))).
typToExpr (tarrow S T) (lam (bind _ (fun l => lam (bind _ 
  (fun t => ite (eunop isFun t) (lam (bind _ (fun x => app (app Ct l) (app t (app (app Cs (neg l)) x))))) (eunop blame l)))))) :-
    typToExpr S Cs,
    typToExpr T Ct.

(* forall contract
 * We have two versions of the contract, TyTrue and TyFalse, which one is used
 * depends on the polarity relative to the polarity at the point the forall is at.
 * They do the opposite of the other, unwrap or wrap the value depending whether the
 * polarity has changed or not.
 * Keep in mind TyTrue and TyFalse is not the instantiation of the variable a to a contract,
 * but the body of the forall applied to different instantiation, and then converted to a contract.
 * A simpler implementation should be possible at the expense of extending Nickel,
 * for now this is the simplest way to proceed.
 *)
typToExpr (forall (bind _ F)) (lam (bind _ (fun l => ite (pos l) (app TyTrue l) (app TyFalse l))))   :-
  typToExpr (F (fromExpr (lam (bind _ (fun lp => lam (bind _ (fun t => 
    ite (pos lp) 
      (unwrap t X (eunop blame lp))
      (wrapper t X)
  ))))))) TyTrue,
  typToExpr (F (fromExpr (lam (bind _ (fun lp => lam (bind _ (fun t => 
    ite (pos lp)
      (wrapper t X)
      (unwrap t X (eunop blame lp))
  ))))))) TyFalse.
typToExpr (fromExpr E) E.

eval : expr -> expr -> prop.

(* label *)
eval (neg L) (label true S) :-
  eval L (label false S).
eval (neg L) (label false S) :-
  eval L (label true S).

eval (pos L) (ebool P) :-
  eval L (label P _).

(* Lazy evaluation *)
eval (thunk _ E V) V' when refl.isunif V :-
  eval E V,
  eq V V'.
eval (thunk _ E V) V' when not (refl.isunif V) :-
  eq V V'.

eval (recThunk S E V) V' when refl.isunif V :-
  eval (E (recThunk S E R)) V,
  eq V V'.
eval (recThunk _ E V) V' when not (refl.isunif V) :-
  eq V V'.

(* wrapping *)
eval (wrapper E A) (wrapper E A).

eval (unwrap X B _) V :-
  eval X (wrapper E A),
  refl.sameunif A B,
  eval E V.
eval (unwrap X B E) V :-
  eval X (wrapper _ A),
  not (refl.sameunif A B),
  eval E V.
eval (unwrap X B E) V :-
  not (eval X (wrapper _ A)),
  eval E V.

(* Lambda constructs *)
eval (let (bind Name E) (bind Name T)) V :-  
  eval (T (recThunk Name E V')) V. 

eval (lam X_Body) (lam X_Body).

eval (app E1 E2) V :-
  eval E1 (lam (bind Name Body)),
  eval (Body (thunk Name E2 Shr)) V.

(* Constants *)
eval (eint N) (eint N).
eval (ebool B) (ebool B).
eval (estr S) (estr S).
eval (label P S) (label P S).

(* Records *)
(* TODO check there are no repeated fields *)

eval (erec []) (erec []).
eval (erec ((static_field S E) :: TL)) (erec ((static_field S E) :: TL')) :-
  eval (erec TL) (erec TL').
eval (erec ((dyn_field S E) :: TL)) (erec ((static_field S' E) :: TL')) :-
  eval S (estr S'),
  eval (erec TL) (erec TL').

find_field : (list rec_field) -> string -> expr -> prop.
find_field ((static_field S E) :: TL) S E.
find_field ((static_field S' _) :: TL) S E :-
  not (eq S' S),
  find_field TL S E.

eval (static_access E S) V :-
  eval E (erec L),
  find_field L S F,
  eval F V.

eval (dyn_access E S) V :-
  eval S (estr S'),
  eval (static_access E S') V.


(* Operations *)
eval (ite C T E) V :-
  eval C (ebool true),
  eval T V.
eval (ite C T E) V :-
  eval C (ebool false),
  eval E V.

eval_binop : binop -> expr -> expr -> expr -> prop.

eval (ebinop E1 Op E2) V :-
  map eval [E1, E2] [V1, V2],
  eval_binop Op V1 V2 V.

eval_binop add (eint N1) (eint N2) (eint N) :- plus N1 N2 N.
eval_binop sub (eint N1) (eint N2) (eint N) :- plus N2 N N1.
eval_binop mul (eint N1) (eint N2) (eint N) :- mult N1 N2 N.

eval_unop : unop -> expr -> expr -> prop.

eval (eunop Op E) V :-
  eval E E',
  eval_unop Op E' V.

eval_unop blame (label true S) _ :- 
  print `Reached a positive blame with label ${S}`,
  failure.
eval_unop blame (label false S) _ :- 
  print `Reached a negative blame with label ${S}`,
  failure.

eval_unop isNum (eint _) (ebool true).
eval_unop isBool (ebool _) (ebool true).
eval_unop isStr (estr _) (ebool true).
eval_unop isRec (erec _) (ebool true). 
eval_unop isFun (lam _) (ebool true).

eval_unop isNum V (ebool false) :- not (eq V (eint _)).
eval_unop isBool V (ebool false) :- not (eq V (ebool _)).
eval_unop isStr V (ebool false) :- not (eq V (estr _)).
eval_unop isRec V (ebool false) :- not (eq V (erec _)).
eval_unop isFun V (ebool false) :- not (eq V (lam _)).

(* Typing *)
(* Promises don't perform any computation *)
eval (promise _ T) V :-
  eval T V.

eval (assume Ty L T) V :-
  typToExpr Ty CTy,
  eval (app (app CTy L) T) V.

(* Variables *)
eval (named X) _ :- print `unknown variable ${X}`, failure.
