
print "Simple example without let" ?

print "Return 6" ?
interpreter "
(fun x => x + x) 3
" V T ?

print "Promises are check before running, assumes after" ?

print "Typecheck fail" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Promise(Num, true))
)
" V T ?

print "Return 3" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Assume(Num, true))
)
" V T ?

print "Blame" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, true))
)
" V T ?

print "Return 5" ?
interpreter "
let ( id = fun t => t ) in

Promise(Num,
Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, 5))
)
" V T ?

print " We don't have let polymorphism (any) " ?

print "Typecheck fail" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise(Num, id 3), Promise(Bool, id true))
" V T ?

print "Return 3" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise(Num, id 3), Assume(Bool, id true))
" V T ?

print "Return true" ?
interpreter "
let (id = fun x => x) in
Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
" V T ?

print "This is bad because order matters!!" ?

print "Typecheck fail" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Assume(Bool, id true), Promise(Num, id 3))
" V T ?

print "We can still use Assume(...)s" ?

print "Return 3" ?
interpreter "
let (id = fun x => x) in
Ifte(true, Promise( Num , id 3), Promise( Bool, Assume( Bool -> Bool , id ) true))
" V T ?

print "Expressions can also be types!" ?

print "Void type (Blame)" ?
interpreter "
let (void = fun l => fun t => blame l) in
Assume(void, 3)
" V T ?

print "alwaysTrue (Blame)" ?
interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
Assume(alwaysTrue, false)
" V T ?

print "Return true" ?
interpreter "
let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
Assume(alwaysTrue, true)
" V T ?

print "Return function" ?
interpreter "
let (void = fun l => fun t => blame l) in
Promise( void -> void, fun x => x) 
" V T ?

print "We also have nice recursive lets" ?

print "Return 3" ?
raw_interpreter "
let (f = fun x => Ifte(x, f false, 3)) in
f true
" V T ?

print "No idea what happens with lets in lets" ?
raw_interpreter "
let (f = (let (f = 3) in f)) in f + f
" V T ?

(*
The reason is that when evaluating the body of the let definition we introduce a fresh variable that accounts for 
the recursive definition, and it may try to escape that context where it exists, not unifying with anything
*)

