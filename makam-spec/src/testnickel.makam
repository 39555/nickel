%use "init".

(* This file defines a bunch of tests across many features
 * of the Makam implementation of the Nickel language.
 *
 * They don't follow any particular organization and should be treated
 * as a minimal set of expected behaviour. Also as examples.
 *)

nickel : testsuite. 

testcase nickel :-
    raw_interpreter "(fun x => x + x) 3" (eint 6) tnum.

testcase nickel :-
    raw_interpreter "let (x = true) in Ifte(x, 34, false)" (eint 34) tdyn.

testcase nickel :-
    not (
        interpreter "
        let ( id = fun t => t ) in
        Promise(Num,
            Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Promise(Num, true)) 
        ) " _ _).

testcase nickel :-
    raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Assume(Num, true))
        )
    " (eint 3) tnum.

testcase nickel :-
    not (
        raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, true))
        )
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let ( id = fun t => t ) in

    Promise(Num,
    Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, 5))
    )
    " (eint 5) tnum.

testcase nickel :-
    not (
        interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Promise(Bool, id true))
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Assume(Bool, id true))
        " (eint 3) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Assume(Bool, id true), Promise(Num, id 3))
    "
    (ebool true)
    tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Promise( Num , id 3), Promise( Bool, Assume( Bool -> Bool , id ) true))
    " (eint 3) tdyn.

testcase nickel :-
    not (
        raw_interpreter "
        let (void = fun l => fun t => blame l) in
        Assume(#void, 3)
        " _ _
    ).

testcase nickel :-
    not (
        raw_interpreter "
        let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
        Assume(#alwaysTrue, false)
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
    Assume(#alwaysTrue, true)
    " (ebool true) (fromExpr (named "alwaysTrue")).

testcase nickel :-
    raw_interpreter "
    let (void = fun l => fun t => blame l) in
    Promise( #void -> #void, fun x => x)" V T,
    eq V (lam (bind "x" (fun x => x))),
    eq T (tarrow (fromExpr (named "void")) (fromExpr (named "void"))).

testcase nickel :-
    raw_interpreter "
    let (f = fun x => Ifte(x, f false, 3)) in
    f true
    " (eint 3) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = (let (f = fun x => 3 - x) in f 1)) in f + f
    " (eint 4) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = fun x => x + 1) in
    fun y => f y" 
    (lam (bind "y" (fun y => app (recThunk "f" (fun f => lam (bind "x" (fun x => ebinop x add (eint 1)))) V') y))) 
    (tarrow tnum tnum).


nickel_typing : testsuite.

testcase nickel_typing :-
    p_typecheck
    "true"
    tbool.

testcase nickel_typing :-
    p_typecheck
    "34"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "34"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "\"hola\""
    tstr.

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow A A).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow tdyn tdyn).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "let (x = 34) in x + 2"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "(fun x => x) 3"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "Promise(Bool -> Bool, fun x => x) 3"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "Promise(Num -> Num, fun x => x) 3"
    tnum.

testcase nickel_typing :-
    not (p_typecheck
        "Promise(Num -> Bool, fun x => x) 3"
        _
    ).
(* forall *)

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) "
    (lam (bind "x" (fun x => x)))
    (forall (bind "a" (fun a => tarrow a a))).

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) 3 "
    (eint 3)
    (tdyn).

testcase nickel :-
    raw_interpreter "
    Assume(forall a . a -> a, fun x => x) 3 "
    (eint 3) tdyn.

testcase nickel :-
    not (raw_interpreter "
    Assume(forall a . a -> a, fun x => 2) 3 "
    _ _).

testcase nickel :-
    raw_interpreter 
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f x) 3) (fun y => 2 + y)"
    (eint 5)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f (f x)) 3) (fun y => 2 + y)"
    (eint 7)
    tdyn.

testcase nickel :-
    not (raw_interpreter
        "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f 2) 34) (fun y => 25 + y)"
        _ _
    ).

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) 3) (fun y => Ifte(isNum y, y, 0))"
    (eint 3)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) true) (fun y => Ifte(isNum y, y, 0))"
    (eint 0)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . forall b . (a -> b) -> a -> b, fun f => f) (fun x => 34)) true"
    (eint 34)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => x)"
    (eint 34)
    tnum.


testcase nickel :-
    not (raw_interpreter
        "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => 2)"
        _ _
    ).
