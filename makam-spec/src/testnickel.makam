%use "init".

(* This file defines a bunch of tests across many features
 * of the Makam implementation of the Nickel language.
 *
 * They don't follow any particular organization and should be treated
 * as a minimal set of expected behaviour. Also as examples.
 *)

nickel : testsuite. 

testcase nickel :-
    raw_interpreter "(fun x => x + x) 3" (eint 6) tnum.

testcase nickel :-
    raw_interpreter "let (x = true) in Ifte(x, 34, false)" (eint 34) tdyn.

testcase nickel :-
    not (
        interpreter "
        let ( id = fun t => t ) in
        Promise(Num,
            Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Promise(Num, true)) 
        ) " _ _).

testcase nickel :-
    raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) true, 3, Assume(Num, true))
        )
    " (eint 3) tnum.

testcase nickel :-
    not (
        raw_interpreter "
        let ( id = fun t => t ) in

        Promise(Num,
        Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, true))
        )
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let ( id = fun t => t ) in

    Promise(Num,
    Ifte( ( Promise(Bool -> Bool, id) ) false, 3, Assume(Num, 5))
    )
    " (eint 5) tnum.

testcase nickel :-
    not (
        interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Promise(Bool, id true))
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
        let (id = fun x => x) in
        Ifte(true, Promise(Num, id 3), Assume(Bool, id true))
        " (eint 3) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(false, Promise(Num, id 3), Assume(Bool, id true))
    " (ebool true) tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Assume(Bool, id true), Promise(Num, id 3))
    "
    (ebool true)
    tdyn.

testcase nickel :-
    raw_interpreter "
    let (id = fun x => x) in
    Ifte(true, Promise( Num , id 3), Promise( Bool, Assume( Bool -> Bool , id ) true))
    " (eint 3) tdyn.

testcase nickel :-
    not (
        raw_interpreter "
        let (void = fun l => fun t => blame l) in
        Assume(#void, 3)
        " _ _
    ).

testcase nickel :-
    not (
        raw_interpreter "
        let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
        Assume(#alwaysTrue, false)
        " _ _
    ).

testcase nickel :-
    raw_interpreter "
    let (alwaysTrue = fun l => fun t => Ifte(t, t, blame l)) in
    Assume(#alwaysTrue, true)
    " (ebool true) (fromExpr (named "alwaysTrue")).

testcase nickel :-
    raw_interpreter "
    let (void = fun l => fun t => blame l) in
    Promise( #void -> #void, fun x => x)" V T,
    eq V (lam (bind "x" (fun x => x))),
    eq T (tarrow (fromExpr (named "void")) (fromExpr (named "void"))).

testcase nickel :-
    raw_interpreter "
    let (f = fun x => Ifte(x, f false, 3)) in
    f true
    " (eint 3) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = (let (f = fun x => 3 - x) in f 1)) in f + f
    " (eint 4) tnum.

testcase nickel :-
    raw_interpreter "
    let (f = fun x => x + 1) in
    fun y => f y" 
    (lam (bind "y" (fun y => app (recThunk "f" (fun f => lam (bind "x" (fun x => ebinop x add (eint 1)))) V') y))) 
    (tarrow tnum tnum).


nickel_typing : testsuite.

testcase nickel_typing :-
    p_typecheck
    "true"
    tbool.

testcase nickel_typing :-
    p_typecheck
    "34"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "34"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "\"hola\""
    tstr.

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow A A).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    (tarrow tdyn tdyn).

testcase nickel_typing :-
    p_typecheck
    "fun x => x"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "let (x = 34) in x + 2"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "(fun x => x) 3"
    tnum.

testcase nickel_typing :-
    p_typecheck
    "Promise(Bool -> Bool, fun x => x) 3"
    tdyn.

testcase nickel_typing :-
    p_typecheck
    "Promise(Num -> Num, fun x => x) 3"
    tnum.

testcase nickel_typing :-
    not (p_typecheck
        "Promise(Num -> Bool, fun x => x) 3"
        _
    ).
(* forall *)

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) "
    (lam (bind "x" (fun x => x)))
    (forall (bind "a" (fun a => tarrow a a))).

testcase nickel :-
    raw_interpreter "
    Promise(forall a . a -> a, fun x => x) 3 "
    (eint 3)
    (tdyn).

testcase nickel :-
    raw_interpreter "
    Assume(forall a . a -> a, fun x => x) 3 "
    (eint 3) tdyn.

testcase nickel :-
    not (raw_interpreter "
    Assume(forall a . a -> a, fun x => 2) 3 "
    _ _).

testcase nickel :-
    raw_interpreter 
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f x) 3) (fun y => 2 + y)"
    (eint 5)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f (f x)) 3) (fun y => 2 + y)"
    (eint 7)
    tdyn.

testcase nickel :-
    not (raw_interpreter
        "(Assume(forall a . a -> (a -> a) ->  a, fun x => fun f => f 2) 34) (fun y => 25 + y)"
        _ _
    ).

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) 3) (fun y => Ifte(isNum y, y, 0))"
    (eint 3)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . a -> (a -> Num) ->  Num, fun x => fun f => f x) true) (fun y => Ifte(isNum y, y, 0))"
    (eint 0)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(forall a . forall b . (a -> b) -> a -> b, fun f => f) (fun x => 34)) true"
    (eint 34)
    tdyn.

testcase nickel :-
    raw_interpreter
    "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => x)"
    (eint 34)
    tnum.


testcase nickel :-
    not (raw_interpreter
        "(Assume(Num -> (forall a. a -> a) -> Num, fun n => fun f => f n) 34) (fun x => 2)"
        _ _
    ).
(isocast "{ hello : 3 ; chau : \"4\" ; $(Ifte(true, \"hello\", \"chau\")) : 5 ; $(Ifte(true, \"hello\", \"chau\")) : 4 }" (E: expr),
typecheck E T) ?

(* Records *)

testcase nickel :-
    raw_interpreter "{$(\"bla\"): 5 }"
    (rec_catcher [ (tuple "bla" (eint 5)) ] (fun s => eunop blame (label false "Wrong record field ${s}")))
    (open_rec tnum []).

testcase nickel :-
    isocast 
    "{ hello : 3 ; chau : \"4\" ; $(Ifte(true, \"hello\", \"chau\")) : 5 ; $(Ifte(true, \"hello\", \"chau\")) : 4 }" 
    (E: expr),
    typecheck E (open_rec tnum [ ("hello", tnum) , ("chau", tstr)]).

testcase nickel :-
    isocast 
    "Promise({ _:Bool, hello: Num}, 3)" 
    (E: expr), 
    not (typecheck E _).

(isocast "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }.$blap" (E: expr), typecheck E T)?
(isocast "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }" (E: expr), typecheck E (open_rec T []))?
(isocast "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }" (E: expr), typecheck E T)?

(isocast "{$(\"bla\"): 5 }" (E: expr), typecheck E T)?

raw_interpreter "{$(\"bla\"): 5 }" E T ?

raw_interpreter "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }" E T ?
raw_interpreter "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : true }.blop" E T ?
raw_interpreter "{$(Ifte(true, \"hello\", \"chau\")) : false; $(\"bla\"): true; blop : 3 }.blop" E T ?


isocast " fun x => (x).hello" (E: expr) ?
raw_interpreter " fun x => (x).hello" (E: expr) T ?
raw_interpreter "(fun x => ((x).hello) + ((x).$\"chau\")) " E T ?
raw_interpreter "(fun x => ((x).hello) + ((x).chau)) { hello: 3; $\"chau\" : 4 }" E T ?
(isocast "(fun x => ((x).hello) + ((x).chau)) { hello: 3; chaup : 4; $\"dope\": 5 }" (E: expr), typecheck E T )?
(isocast "(fun x => ((x).hello) + ((x).$\"chau\")) { hello: 3; chaup : 4; $\"dope\": false }" (E: expr), typecheck E T )?

(isocast "(Assume( { hello : Bool } , {$\"hello\": true; chau: 3}))" (E:expr), typecheck E T) ?
raw_interpreter "Assume({ hello : Bool }, {$\"hello\": true; chau: 3}).hello" E T ?
raw_interpreter "(Assume({ hello : (Bool -> Bool) }, {$\"hello\": (fun x => Ifte(x, false, true)); chau: 3}).hello) 4" E T ?
raw_interpreter "(Assume({ _: Bool , hello : (Bool -> Bool) }, {$\"hello\": (fun x => Ifte(x, false, true)); chau: 3}).hello) false" E T ?
raw_interpreter "(Assume({ _: Bool , hello : (Bool -> Bool) }, {$\"hello\": (fun x => Ifte(x, false, true)); chau: false}).chau)" E T ?
