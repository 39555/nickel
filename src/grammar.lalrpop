use identifier::Ident;
use std::str::FromStr;
use term::Term;
use label::Label;
use operation::{UnaryOp, BinaryOp};

grammar;

pub Term = {
    "fun" <ps:Pattern+> "=>" <t:Term> =>
        Term::Fun(ps, Box::new(t)),
    "let" <id:Ident> "=" <t1:Term> "in" <t2:Term> =>
        Term::Let(id, Box::new(t1), Box::new(t2)),
    "if" <b:Term> "then" <t:Term> "else" <e:Term> =>
        Term::App(Box::new(Term::App(Box::new(Term::Op1(UnaryOp::Ite(), Box::new(b))), Box::new(t))), Box::new(e)),
    Operation    
};

Operation: Term = {
    <t1: Applicative> <op: BOp> <t2: Operation> => Term::Op2(op, Box::new(t1), Box::new(t2)),
    <op: UOp> <t: Operation> => Term::Op1(op, Box::new(t)),
    Applicative,
};

Applicative: Term = {
    <t1:Applicative> <t2:Atom> => Term::App(Box::new(t1), Box::new(t2)),
    Atom,
};

Atom: Term = {
    "(" <Term> ")",
    <l:@L> "Promise(" <c: Term> "," <t: Term> ")" <r:@R> =>
        Term::Promise(Box::new(c), Label{tag: "A promise".to_string(), l: l, r: r}, Box::new(t)),
    <l:@L> "Assume(" <c: Term> "," <t: Term> ")" <r:@R> =>
        Term::Assume(Box::new(c), Label{tag: "An assume".to_string(), l: l, r: r}, Box::new(t)), 
    Num => Term::Num(<>),
    Bool => Term::Bool(<>),
    Ident => Term::Var(<>),
};

Pattern: Ident = {
    Ident,
};

Ident: Ident = r"[[:alpha:]_][[:word:]-]*" => Ident(<>.to_string());

Num: f64 = r"[-+]?[0-9]*\.?[0-9]+" => f64::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

UOp: UnaryOp = {
    "isZero" => UnaryOp::IsZero(),
    "isNum" => UnaryOp::IsNum(),
    "isBool" => UnaryOp::IsBool(),
    "isFun" => UnaryOp::IsFun(),
    "blame" => UnaryOp::Blame(),
};

BOp: BinaryOp = {
    "+" => BinaryOp::Plus(),
};


