use identifier::Ident;
use std::str::FromStr;
use term::Term;
use label::Label;

grammar;

pub Term = {
    "fun" <ps:Pattern+> "=>" <t:Term> =>
        Term::Fun(ps, Box::new(t)),
    "let" <id:Ident> "=" <t1:Term> "in" <t2:Term> =>
        Term::Let(id, Box::new(t1), Box::new(t2)),
    "if" <b:Term> "then" <t:Term> "else" <e:Term> =>
        Term::Ite(Box::new(b), Box::new(t), Box::new(e)),
    // TODO make infix
    "+" <t1:Atom> <t2:Atom> => Term::Plus(Box::new(t1), Box::new(t2)),
    "isZero" <Atom> => Term::IsZero(Box::new(<>)),
    "isNum" <Atom> => Term::IsNum(Box::new(<>)),
    "isBool" <Atom> => Term::IsBool(Box::new(<>)),
    "isFun" <Atom> => Term::IsFun(Box::new(<>)),
    "blame" <lab:Term> => Term::Blame(Box::new(lab)),
    Applicative,
};

Atom: Term = {
    "(" <Term> ")",
    // label syntax is used only for debugging for now, will be deprecated
    <l:@L> "label[" <s:Str> "]" <r:@R> => Term::Lbl(Label{tag: s, l: l, r: r}),
    Num => Term::Num(<>),
    Bool => Term::Bool(<>),
    Ident => Term::Var(<>),
}

Applicative: Term = {
    Atom,
    <t1:Applicative> <t2:Atom> => Term::App(Box::new(t1), Box::new(t2)),
}

Pattern: Ident = {
    Ident,
}

Ident: Ident = r"[[:alpha:]_][[:word:]-]*" => Ident(<>.to_string());

Num: f64 = r"[-+]?[0-9]*\.?[0-9]+" => f64::from_str(<>).unwrap();

Bool: bool = {
    "true" => true,
    "false" => false,
};

Str: String = r"[[:alpha:]_][[:word:]-]*" => <>.to_string();

